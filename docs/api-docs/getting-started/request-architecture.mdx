## API Request Architecture

The **Unlimited** rate plan for BigCommerce Enterprise clients means that these stores are not rate limited by request magnitude per unit of time. However, there are physical infrastructure-related constraints that may limit the maximum throughput of requests for a given resource. 

Regardless of whether your store or the stores your app serves are rate limited, good design patterns are both responsible stewards of our API ecosystem and critical to healthy, performant apps and headless storefronts. This article describes three tenets of good SaaS design patterns; [efficiency](#efficiency), [mindfulness](#mindfulness), and [responsiveness](#responsiveness).

## Efficiency

**Make as few calls as possible; request only information that your app requires to function.**

When interacting with a resource on a store, consider how many calls it takes to accomplish the goal. When you fetch information, investigate whether you can use a bulk endpoint instead of retrieving resources one by one. If possible, use the bulk endpoint and filter the data to retrieve only what you need. For example, the [REST Catalog API](/docs/rest-catalog/products) contains both [Get a product](/docs/rest-catalog/products#get-a-product) and [Get all products](/docs/rest-content/pages#get-pages). If your app or storefront requests one or more products, you can use [Get all products](/docs/rest-content/pages#get-pages) and filter which products you'd like to retrieve using the `id:in` query parameter.

The same principle applies for bulk endpoints. The base number of resources returned from a bulk request is 50. If you need to retrieve 5,000 products, the default response pagination limit requires you to make 100 API calls to the bulk endpoint. Instead, you can use query parameters to set the response limit to 250 and request the same information in 20 calls.

The same efficency principle extends to creating and updating resources.

In addition, consider using conditional logic to avoid making API calls when they are not needed. If the resource hasn't changed or the app conditions are such that more API data is not helpful at that time. You can use [webhooks (Overview)](/docs/webhooks/overview) to trigger fetch and update requests as they become relevant, rather than polling the API.

## Mindfulness

**There should be a distinct purpose behind each API call.** 

The existence of unlimited API does not predicate making unlimited requests. This is in the same vein of an unlimited data plan, in that yes they will allow you unlimited data on the network but after a certain point if you are abusing it (constantly downloading/uploading/streaming) they will throttle you.

Resource calls requiring a body (typically creation and updating) are more resource intensive than requesting or deleting. When a resource is updated there should be an inciting action, either the resource in our end being affected (verifying by webhook) or a change in an external resource controller requiring the product in BC to be changed to match.

## Responsiveness

**Shift tactics when your requests return errors.**

Larger merchants typically will have resources that shift more often. These types of merchants typically will utilize our APIs in a much more aggressive way given their business model. However the interaction between ERP and BC is a two-way street. Proper error handling is a requirement from the erp. If we are telling you to stop using http codes, your service should consider what is happening rather than continuing to send requests to resources.

4xx errors: 404 and 422 errors are common with sync systems. A resource gets moved, changed, or removed so we return a 404 on it. This should indicate to the ERP that it should re-evaluate where this resource is and act accordingly. Similarly with 422, if a resource is attempting to be updated incorrectly and we are informing you of it, you should heed the warning and reflect on what is being sent.

429: These should be heeded without question. If your ERP starts receiving intermittent 429s on a call (typically to the same resource) it needs to halt. Utilize our pre-existing retry header features as necessary, but when we are telling you you are going to fast you need to listen.

5xxs: In the event of a 500 error there should be a retry mechanism in place to attempt the transaction again. When updating or creating resources the chances are higher that there is a contention for the resource your are actively trying to update, so this retry attempt should be held for a bit longer than for example requesting the resource. If many separate uris are returning 5xxs then consider pausing the sync and checking status.bigcommerce.com
